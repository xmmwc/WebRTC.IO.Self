var PeerConnection = window.PeerConnection || window.webkitPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
var SessionDescription = window.RTCSessionDescription || window.webkitSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;
var IceCandidate = window.RTCIceCandidate || window.webkitIceCandidate || window.mozRTCIceCandidate || window.webkitRTCIceCandidate;
var URL = window.URL || window.webkitURL || window.msURL || window.oURL;
var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

(function(){

    var rtc = {};

    rtc.socket = null;

    rtc.SERVER = {
        iceServers: [
            {url: "stun:stun.l.google.com:19302"}
        ]
    };

    // Referenc e to the lone PeerConnection instance.
    rtc.peerConnections = {};

    // Array of known peer socket ids
    rtc.connections = [];
    // Stream-related variables.
    rtc.streams = [];
    rtc.numStreams = 0;
    rtc.initializedStreams = 0;

    rtc.connect = function(server,room) {
        room = room || '';

        rtc.socket = io.connect(server);

        rtc.socket.emit('join_room',room);

        rtc.get_peers = function(data){
            rtc.connections = data.connections;
            //rtc.fire('connections', rtc.connections);
        };

        rtc.receive_ice_candidate = function(data){
            var candidate = new IceCandidate(data);
            rtc.peerConnections[data.socketId].addIceCandidate(candidate);
            //rtc.fire('receive ice candidate', candidate);
        };

        rtc.new_peer_connected = function(data){
            rtc.connections.push(data.socketId);
            var pc = rtc.createPeerConnection(data.socketId);
            for (var i = 0; i < rtc.streams.length; i++) {
                var stream = rtc.streams[i];
                pc.addStream(stream);
            }
        };

        rtc.remove_peer_connected = function(data){
            //rtc.fire('disconnect stream', data.socketId);
            delete rtc.peerConnections[data.socketId];
        };

        rtc.receive_offer = function(data){
            rtc.receiveOffer(data.socketId, data.sdp);
            //rtc.fire('receive offer', data);
        };

        rtc.receive_answer = function(data){
            rtc.receiveAnswer(data.socketId, data.sdp);
            //rtc.fire('receive answer', data);
        }
    };

    rtc.createPeerConnections = function() {
        for (var i = 0; i < rtc.connections.length; i++) {
            rtc.createPeerConnection(rtc.connections[i]);
        }
    };

    rtc.createPeerConnection = function(id,on_ice_candidate,on_open,on_addstream) {
        console.log('createPeerConnection');
        var pc = rtc.peerConnections[id] = new PeerConnection(rtc.SERVER);
        pc.onicecandidate = function(event) {
            if (event.candidate) {
                rtc.socket.emit('send_ice_candidate',{
                    label: event.candidate.label,
                    candidate: event.candidate.candidate,
                    socketId: id
                });
            }
            if(typeof on_ice_candidate == 'function'){
                on_ice_candidate(event.candidate);
            }
            //rtc.fire('ice candidate', event.candidate);
        };

        pc.onopen = function() {
            // TODO: Finalize this API
            //rtc.fire('peer connection opened');
            if(typeof on_open == 'function'){
                on_open('peer connection opened');
            }
        };

        pc.onaddstream = function(event) {
            // TODO: Finalize this API
            //rtc.fire('add remote stream', event.stream, id);
            if(typeof on_addstream == 'function'){
                on_addstream(event.stream, id);
            }
        };
        return pc;
    };

    rtc.sendOffers = function() {
        for (var i = 0, len = rtc.connections.length; i < len; i++) {
            var socketId = rtc.connections[i];
            rtc.sendOffer(socketId);
        }
    };

    rtc.sendOffer = function(socketId) {
        var pc = rtc.peerConnections[socketId];
        pc.createOffer(function (session_description) {
            pc.setLocalDescription(session_description);
            rtc.socket.emit('send_offer',{
                socketId: socketId,
                sdp: session_description
            });
        },function(error){
            if (error) {
                console.log(error);
            }
        });
    };

    rtc.onClose = function(data) {
        rtc.on('close_stream', function() {
            rtc.fire('close_stream', data);
        });
    };

}).call(this);